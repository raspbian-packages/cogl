<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CoglFramebuffer: The Framebuffer Interface</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Cogl 2.0 Reference Manual">
<link rel="up" href="cogl-framebuffer-apis.html" title="Framebuffers">
<link rel="prev" href="cogl-framebuffer-apis.html" title="Framebuffers">
<link rel="next" href="cogl-2.0-experimental-Offscreen-Framebuffers.html" title="Offscreen Framebuffers">
<meta name="generator" content="GTK-Doc V1.18.1 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
<tr valign="middle">
<td><a accesskey="p" href="cogl-framebuffer-apis.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="cogl-framebuffer-apis.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">Cogl 2.0 Reference Manual</th>
<td><a accesskey="n" href="cogl-2.0-experimental-Offscreen-Framebuffers.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr>
<tr><td colspan="5" class="shortcuts">
<a href="#cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.synopsis" class="shortcut">Top</a>
                   | 
                  <a href="#cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.description" class="shortcut">Description</a>
</td></tr>
</table>
<div class="refentry">
<a name="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface"></a><div class="titlepage"></div>
<div class="refnamediv"><table width="100%"><tr>
<td valign="top">
<h2><span class="refentrytitle"><a name="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.top_of_page"></a>CoglFramebuffer: The Framebuffer Interface</span></h2>
<p>CoglFramebuffer: The Framebuffer Interface — A common interface for manipulating framebuffers</p>
</td>
<td valign="top" align="right"></td>
</tr></table></div>
<div class="refsynopsisdiv">
<a name="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.synopsis"></a><h2>Synopsis</h2>
<pre class="synopsis">                    <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer">CoglFramebuffer</a>;
#define             <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#COGL-FRAMEBUFFER:CAPS" title="COGL_FRAMEBUFFER()">COGL_FRAMEBUFFER</a>                    (X)
<a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-allocate" title="cogl_framebuffer_allocate ()">cogl_framebuffer_allocate</a>           (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a href="http://library.gnome.org/devel/glib/unstable/glib-Error-Reporting.html#GError"><span class="type">GError</span></a> **error</code></em>);
<span class="returnvalue">int</span>                 <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-width" title="cogl_framebuffer_get_width ()">cogl_framebuffer_get_width</a>          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">int</span>                 <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-height" title="cogl_framebuffer_get_height ()">cogl_framebuffer_get_height</a>         (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-viewport" title="cogl_framebuffer_set_viewport ()">cogl_framebuffer_set_viewport</a>       (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> height</code></em>);
<span class="returnvalue">float</span>               <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-viewport-x" title="cogl_framebuffer_get_viewport_x ()">cogl_framebuffer_get_viewport_x</a>     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">float</span>               <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-viewport-y" title="cogl_framebuffer_get_viewport_y ()">cogl_framebuffer_get_viewport_y</a>     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">float</span>               <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-viewport-width" title="cogl_framebuffer_get_viewport_width ()">cogl_framebuffer_get_viewport_width</a> (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">float</span>               <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-viewport-height" title="cogl_framebuffer_get_viewport_height ()">cogl_framebuffer_get_viewport_height</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-viewport4fv" title="cogl_framebuffer_get_viewport4fv ()">cogl_framebuffer_get_viewport4fv</a>    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> *viewport</code></em>);
<a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglPixelFormat" title="enum CoglPixelFormat"><span class="returnvalue">CoglPixelFormat</span></a>     <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-color-format" title="cogl_framebuffer_get_color_format ()">cogl_framebuffer_get_color_format</a>   (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">int</span>                 <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-red-bits" title="cogl_framebuffer_get_red_bits ()">cogl_framebuffer_get_red_bits</a>       (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">int</span>                 <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-green-bits" title="cogl_framebuffer_get_green_bits ()">cogl_framebuffer_get_green_bits</a>     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">int</span>                 <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-blue-bits" title="cogl_framebuffer_get_blue_bits ()">cogl_framebuffer_get_blue_bits</a>      (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglColorMask" title="enum CoglColorMask"><span class="returnvalue">CoglColorMask</span></a>       <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-color-mask" title="cogl_framebuffer_get_color_mask ()">cogl_framebuffer_get_color_mask</a>     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-color-mask" title="cogl_framebuffer_set_color_mask ()">cogl_framebuffer_set_color_mask</a>     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglColorMask" title="enum CoglColorMask"><span class="type">CoglColorMask</span></a> color_mask</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-resolve-samples" title="cogl_framebuffer_resolve_samples ()">cogl_framebuffer_resolve_samples</a>    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-resolve-samples-region" title="cogl_framebuffer_resolve_samples_region ()">cogl_framebuffer_resolve_samples_region</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> height</code></em>);
<span class="returnvalue">CoglContext</span> *       <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-context" title="cogl_framebuffer_get_context ()">cogl_framebuffer_get_context</a>        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-clear" title="cogl_framebuffer_clear ()">cogl_framebuffer_clear</a>              (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">unsigned long </span> buffers</code></em>,
                                                         <em class="parameter"><code>const <a class="link" href="cogl-2.0-experimental-Color-Type.html#CoglColor" title="struct CoglColor"><span class="type">CoglColor</span></a> *color</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-clear4f" title="cogl_framebuffer_clear4f ()">cogl_framebuffer_clear4f</a>            (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">unsigned long </span> buffers</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> red</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> green</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> blue</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> alpha</code></em>);
<a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-read-pixels-into-bitmap" title="cogl_framebuffer_read_pixels_into_bitmap ()">cogl_framebuffer_read_pixels_into_bitmap</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-The-Top-Level-Context.html#CoglReadPixelsFlags" title="enum CoglReadPixelsFlags"><span class="type">CoglReadPixelsFlags</span></a> source</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Bitmaps.html#CoglBitmap"><span class="type">CoglBitmap</span></a> *bitmap</code></em>);
<a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-read-pixels" title="cogl_framebuffer_read_pixels ()">cogl_framebuffer_read_pixels</a>        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> height</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglPixelFormat" title="enum CoglPixelFormat"><span class="type">CoglPixelFormat</span></a> format</code></em>,
                                                         <em class="parameter"><code><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#guint8"><span class="type">guint8</span></a> *pixels</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-dither-enabled" title="cogl_framebuffer_set_dither_enabled ()">cogl_framebuffer_set_dither_enabled</a> (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="type">gboolean</span></a> dither_enabled</code></em>);
<a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-dither-enabled" title="cogl_framebuffer_get_dither_enabled ()">cogl_framebuffer_get_dither_enabled</a> (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);

<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-primitive" title="cogl_framebuffer_draw_primitive ()">cogl_framebuffer_draw_primitive</a>     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Primitives.html#CoglPrimitive" title="CoglPrimitive"><span class="type">CoglPrimitive</span></a> *primitive</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-attributes" title="cogl_framebuffer_draw_attributes ()">cogl_framebuffer_draw_attributes</a>    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglAttribute</span> **attributes</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_attributes</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-vdraw-attributes" title="cogl_framebuffer_vdraw_attributes ()">cogl_framebuffer_vdraw_attributes</a>   (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code>...</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-indexed-attributes" title="cogl_framebuffer_draw_indexed_attributes ()">cogl_framebuffer_draw_indexed_attributes</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglIndices</span> *indices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglAttribute</span> **attributes</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_attributes</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-vdraw-indexed-attributes" title="cogl_framebuffer_vdraw_indexed_attributes ()">cogl_framebuffer_vdraw_indexed_attributes</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglIndices</span> *indices</code></em>,
                                                         <em class="parameter"><code>...</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-rectangle" title="cogl_framebuffer_draw_rectangle ()">cogl_framebuffer_draw_rectangle</a>     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-textured-rectangle" title="cogl_framebuffer_draw_textured_rectangle ()">cogl_framebuffer_draw_textured_rectangle</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> s_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> t_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> s_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> t_2</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-multitextured-rectangle" title="cogl_framebuffer_draw_multitextured_rectangle ()">cogl_framebuffer_draw_multitextured_rectangle</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>,
                                                         <em class="parameter"><code>const <span class="type">float</span> *tex_coords</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> tex_coords_len</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-rectangles" title="cogl_framebuffer_draw_rectangles ()">cogl_framebuffer_draw_rectangles</a>    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code>const <span class="type">float</span> *verts</code></em>,
                                                         <em class="parameter"><code>unsigned <span class="type">int</span> n_rects</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-textured-rectangles" title="cogl_framebuffer_draw_textured_rectangles ()">cogl_framebuffer_draw_textured_rectangles</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code>const <span class="type">float</span> *coordinates</code></em>,
                                                         <em class="parameter"><code>unsigned <span class="type">int</span> n_rectangles</code></em>);

<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-finish" title="cogl_framebuffer_finish ()">cogl_framebuffer_finish</a>             (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);

<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-push-matrix" title="cogl_framebuffer_push_matrix ()">cogl_framebuffer_push_matrix</a>        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-pop-matrix" title="cogl_framebuffer_pop_matrix ()">cogl_framebuffer_pop_matrix</a>         (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-identity-matrix" title="cogl_framebuffer_identity_matrix ()">cogl_framebuffer_identity_matrix</a>    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-scale" title="cogl_framebuffer_scale ()">cogl_framebuffer_scale</a>              (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-translate" title="cogl_framebuffer_translate ()">cogl_framebuffer_translate</a>          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-rotate" title="cogl_framebuffer_rotate ()">cogl_framebuffer_rotate</a>             (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> angle</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-transform" title="cogl_framebuffer_transform ()">cogl_framebuffer_transform</a>          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code>const <a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-modelview-matrix" title="cogl_framebuffer_get_modelview_matrix ()">cogl_framebuffer_get_modelview_matrix</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-modelview-matrix" title="cogl_framebuffer_set_modelview_matrix ()">cogl_framebuffer_set_modelview_matrix</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);

<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-perspective" title="cogl_framebuffer_perspective ()">cogl_framebuffer_perspective</a>        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> fov_y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> aspect</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_near</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_far</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-frustum" title="cogl_framebuffer_frustum ()">cogl_framebuffer_frustum</a>            (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> left</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> right</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bottom</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> top</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_near</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_far</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-orthographic" title="cogl_framebuffer_orthographic ()">cogl_framebuffer_orthographic</a>       (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> near</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> far</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-get-projection-matrix" title="cogl_framebuffer_get_projection_matrix ()">cogl_framebuffer_get_projection_matrix</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-projection-matrix" title="cogl_framebuffer_set_projection_matrix ()">cogl_framebuffer_set_projection_matrix</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);

<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-push-scissor-clip" title="cogl_framebuffer_push_scissor_clip ()">cogl_framebuffer_push_scissor_clip</a>  (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> height</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-push-rectangle-clip" title="cogl_framebuffer_push_rectangle_clip ()">cogl_framebuffer_push_rectangle_clip</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-push-primitive-clip" title="cogl_framebuffer_push_primitive_clip ()">cogl_framebuffer_push_primitive_clip</a>
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Primitives.html#CoglPrimitive" title="CoglPrimitive"><span class="type">CoglPrimitive</span></a> *primitive</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_x1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_y1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_x2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_y2</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-pop-clip" title="cogl_framebuffer_pop_clip ()">cogl_framebuffer_pop_clip</a>           (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);

<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="returnvalue">CoglFramebuffer</span></a> *   <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-get-draw-framebuffer" title="cogl_get_draw_framebuffer ()">cogl_get_draw_framebuffer</a>           (<em class="parameter"><code><span class="type">void</span></code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-set-framebuffer" title="cogl_set_framebuffer ()">cogl_set_framebuffer</a>                (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *buffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-push-framebuffer" title="cogl_push_framebuffer ()">cogl_push_framebuffer</a>               (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *buffer</code></em>);
<span class="returnvalue">void</span>                <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-pop-framebuffer" title="cogl_pop_framebuffer ()">cogl_pop_framebuffer</a>                (<em class="parameter"><code><span class="type">void</span></code></em>);
</pre>
</div>
<div class="refsect1">
<a name="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.description"></a><h2>Description</h2>
<p>
Framebuffers are a collection of buffers that can be rendered too.
A framebuffer may be comprised of one or more color buffers, an
optional depth buffer and an optional stencil buffer. Other
configuration parameters are associated with framebuffers too such
as whether the framebuffer supports multi-sampling (an anti-aliasing
technique) or dithering.
</p>
<p>
There are two kinds of framebuffer in Cogl, <span class="type">CoglOnscreen</span>
framebuffers and <span class="type">CoglOffscreen</span> framebuffers. As the names imply
offscreen framebuffers are for rendering something offscreen
(perhaps to a texture which is bound as one of the color buffers).
The exact semantics of onscreen framebuffers depends on the window
system backend that you are using, but typically you can expect
rendering to a <span class="type">CoglOnscreen</span> framebuffer will be immediately
visible to the user.
</p>
<p>
If you want to create a new framebuffer then you should start by
looking at the <span class="type">CoglOnscreen</span> and <span class="type">CoglOffscreen</span> constructor
functions, such as <a class="link" href="cogl-2.0-experimental-Offscreen-Framebuffers.html#cogl-offscreen-new-to-texture" title="cogl_offscreen_new_to_texture ()"><code class="function">cogl_offscreen_new_to_texture()</code></a> or
<code class="function">cogl_onscreen_new()</code>. The <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> interface deals with
all aspects that are common between those two types of framebuffer.
</p>
<p>
Setup of a new CoglFramebuffer happens in two stages. There is a
configuration stage where you specify all the options and ancillary
buffers you want associated with your framebuffer and then when you
are happy with the configuration you can "allocate" the framebuffer
using <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-allocate" title="cogl_framebuffer_allocate ()"><code class="function">cogl_framebuffer_allocate()</code></a>. Technically explicitly calling
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-allocate" title="cogl_framebuffer_allocate ()"><code class="function">cogl_framebuffer_allocate()</code></a> is optional for convenience and the
framebuffer will automatically be allocated when you first try to
draw to it, but if you do the allocation manually then you can
also catch any possible errors that may arise from your
configuration.
</p>
</div>
<div class="refsect1">
<a name="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.details"></a><h2>Details</h2>
<div class="refsect2">
<a name="CoglFramebuffer"></a><h3>CoglFramebuffer</h3>
<pre class="programlisting">typedef struct _CoglFramebuffer CoglFramebuffer;</pre>
</div>
<hr>
<div class="refsect2">
<a name="COGL-FRAMEBUFFER:CAPS"></a><h3>COGL_FRAMEBUFFER()</h3>
<pre class="programlisting">#define COGL_FRAMEBUFFER(X) ((CoglFramebuffer *)(X))
</pre>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-allocate"></a><h3>cogl_framebuffer_allocate ()</h3>
<pre class="programlisting"><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            cogl_framebuffer_allocate           (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a href="http://library.gnome.org/devel/glib/unstable/glib-Error-Reporting.html#GError"><span class="type">GError</span></a> **error</code></em>);</pre>
<p>
Explicitly allocates a configured <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> allowing developers to
check and handle any errors that might arise from an unsupported
configuration so that fallback configurations may be tried.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>Many applications don't support any fallback options at least when
they are initially developed and in that case the don't need to use this API
since Cogl will automatically allocate a framebuffer when it first gets
used.  The disadvantage of relying on automatic allocation is that the
program will abort with an error message if there is an error during
automatic allocation.</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>error</code></em> :</span></p></td>
<td>A pointer to a <a href="http://library.gnome.org/devel/glib/unstable/glib-Error-Reporting.html#GError"><span class="type">GError</span></a> for returning exceptions.</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>
<a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> if there were no error allocating the framebuffer, else <a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a>.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-width"></a><h3>cogl_framebuffer_get_width ()</h3>
<pre class="programlisting"><span class="returnvalue">int</span>                 cogl_framebuffer_get_width          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Queries the current width of the given <em class="parameter"><code>framebuffer</code></em>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>The width of <em class="parameter"><code>framebuffer</code></em>.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-height"></a><h3>cogl_framebuffer_get_height ()</h3>
<pre class="programlisting"><span class="returnvalue">int</span>                 cogl_framebuffer_get_height         (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Queries the current height of the given <em class="parameter"><code>framebuffer</code></em>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>The height of <em class="parameter"><code>framebuffer</code></em>.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-set-viewport"></a><h3>cogl_framebuffer_set_viewport ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_set_viewport       (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> height</code></em>);</pre>
<p>
Defines a scale and offset for everything rendered relative to the
top-left of the destination framebuffer.
</p>
<p>
By default the viewport has an origin of (0,0) and width and height
that match the framebuffer's size. Assuming a default projection and
modelview matrix then you could translate the contents of a window
down and right by leaving the viewport size unchanged by moving the
offset to (10,10). The viewport coordinates are measured in pixels.
If you left the x and y origin as (0,0) you could scale the windows
contents down by specify and width and height that's half the real
size of the framebuffer.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>Although the function takes floating point arguments, existing
drivers only allow the use of integer values. In the future floating
point values will be exposed via a checkable feature.</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>The top-left x coordinate of the viewport origin (only integers
supported currently)</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>The top-left y coordinate of the viewport origin (only integers
supported currently)</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>width</code></em> :</span></p></td>
<td>The width of the viewport (only integers supported currently)</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>height</code></em> :</span></p></td>
<td>The height of the viewport (only integers supported currently)</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-viewport-x"></a><h3>cogl_framebuffer_get_viewport_x ()</h3>
<pre class="programlisting"><span class="returnvalue">float</span>               cogl_framebuffer_get_viewport_x     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Queries the x coordinate of the viewport origin as set using <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-viewport" title="cogl_framebuffer_set_viewport ()"><code class="function">cogl_framebuffer_set_viewport()</code></a>
or the default value which is <code class="literal">0</code>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>The x coordinate of the viewport origin.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-viewport-y"></a><h3>cogl_framebuffer_get_viewport_y ()</h3>
<pre class="programlisting"><span class="returnvalue">float</span>               cogl_framebuffer_get_viewport_y     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Queries the y coordinate of the viewport origin as set using <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-viewport" title="cogl_framebuffer_set_viewport ()"><code class="function">cogl_framebuffer_set_viewport()</code></a>
or the default value which is <code class="literal">0</code>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>The y coordinate of the viewport origin.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-viewport-width"></a><h3>cogl_framebuffer_get_viewport_width ()</h3>
<pre class="programlisting"><span class="returnvalue">float</span>               cogl_framebuffer_get_viewport_width (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Queries the width of the viewport as set using <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-viewport" title="cogl_framebuffer_set_viewport ()"><code class="function">cogl_framebuffer_set_viewport()</code></a>
or the default value which is the width of the framebuffer.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>The width of the viewport.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-viewport-height"></a><h3>cogl_framebuffer_get_viewport_height ()</h3>
<pre class="programlisting"><span class="returnvalue">float</span>               cogl_framebuffer_get_viewport_height
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Queries the height of the viewport as set using <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-viewport" title="cogl_framebuffer_set_viewport ()"><code class="function">cogl_framebuffer_set_viewport()</code></a>
or the default value which is the height of the framebuffer.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>The height of the viewport.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-viewport4fv"></a><h3>cogl_framebuffer_get_viewport4fv ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_get_viewport4fv    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> *viewport</code></em>);</pre>
<p>
Queries the x, y, width and height components of the current viewport as set
using <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-viewport" title="cogl_framebuffer_set_viewport ()"><code class="function">cogl_framebuffer_set_viewport()</code></a> or the default values which are 0, 0,
framebuffer_width and framebuffer_height.  The values are written into the
given <em class="parameter"><code>viewport</code></em> array.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>viewport</code></em> :</span></p></td>
<td>A pointer to an array of 4 floats to receive the (x, y, width, height)
components of the current viewport.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-color-format"></a><h3>cogl_framebuffer_get_color_format ()</h3>
<pre class="programlisting"><a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglPixelFormat" title="enum CoglPixelFormat"><span class="returnvalue">CoglPixelFormat</span></a>     cogl_framebuffer_get_color_format   (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Queries the common <a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglPixelFormat" title="enum CoglPixelFormat"><span class="type">CoglPixelFormat</span></a> of all color buffers attached
to this framebuffer. For an offscreen framebuffer created with
<a class="link" href="cogl-2.0-experimental-Offscreen-Framebuffers.html#cogl-offscreen-new-to-texture" title="cogl_offscreen_new_to_texture ()"><code class="function">cogl_offscreen_new_to_texture()</code></a> this will correspond to the format
of the texture.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> framebuffer</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-red-bits"></a><h3>cogl_framebuffer_get_red_bits ()</h3>
<pre class="programlisting"><span class="returnvalue">int</span>                 cogl_framebuffer_get_red_bits       (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Retrieves the number of red bits of <em class="parameter"><code>framebuffer</code></em>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>a pointer to a <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>the number of bits</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-green-bits"></a><h3>cogl_framebuffer_get_green_bits ()</h3>
<pre class="programlisting"><span class="returnvalue">int</span>                 cogl_framebuffer_get_green_bits     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Retrieves the number of green bits of <em class="parameter"><code>framebuffer</code></em>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>a pointer to a <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>the number of bits</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-blue-bits"></a><h3>cogl_framebuffer_get_blue_bits ()</h3>
<pre class="programlisting"><span class="returnvalue">int</span>                 cogl_framebuffer_get_blue_bits      (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Retrieves the number of blue bits of <em class="parameter"><code>framebuffer</code></em>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>a pointer to a <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>the number of bits</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-color-mask"></a><h3>cogl_framebuffer_get_color_mask ()</h3>
<pre class="programlisting"><a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglColorMask" title="enum CoglColorMask"><span class="returnvalue">CoglColorMask</span></a>       cogl_framebuffer_get_color_mask     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Gets the current <a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglColorMask" title="enum CoglColorMask"><span class="type">CoglColorMask</span></a> of which channels would be written to the
current framebuffer. Each bit set in the mask means that the
corresponding color would be written.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>a pointer to a <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglColorMask" title="enum CoglColorMask"><span class="type">CoglColorMask</span></a>
</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-set-color-mask"></a><h3>cogl_framebuffer_set_color_mask ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_set_color_mask     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglColorMask" title="enum CoglColorMask"><span class="type">CoglColorMask</span></a> color_mask</code></em>);</pre>
<p>
Defines a bit mask of which color channels should be written to the
given <em class="parameter"><code>framebuffer</code></em>. If a bit is set in <em class="parameter"><code>color_mask</code></em> that means that
color will be written.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>a pointer to a <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>color_mask</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglColorMask" title="enum CoglColorMask"><span class="type">CoglColorMask</span></a> of which color channels to write to
the current framebuffer.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-resolve-samples"></a><h3>cogl_framebuffer_resolve_samples ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_resolve_samples    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
When point sample rendering (also known as multisample rendering)
has been enabled via <code class="function">cogl_framebuffer_set_samples_per_pixel()</code>
then you can optionally call this function (or
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-resolve-samples-region" title="cogl_framebuffer_resolve_samples_region ()"><code class="function">cogl_framebuffer_resolve_samples_region()</code></a>) to explicitly resolve
the point samples into values for the final color buffer.
</p>
<p>
Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.
</p>
<p>
Since Cogl will automatically ensure samples are resolved if the
target color buffer is used as a source this API only needs to be
used if explicit control is desired - perhaps because you want to
ensure that the resolve is completed in advance to avoid later
having to wait for the resolve to complete.
</p>
<p>
If you are performing incremental updates to a framebuffer you
should consider using <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-resolve-samples-region" title="cogl_framebuffer_resolve_samples_region ()"><code class="function">cogl_framebuffer_resolve_samples_region()</code></a>
instead to avoid resolving redundant pixels.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> framebuffer</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-resolve-samples-region"></a><h3>cogl_framebuffer_resolve_samples_region ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_resolve_samples_region
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> height</code></em>);</pre>
<p>
When point sample rendering (also known as multisample rendering)
has been enabled via <code class="function">cogl_framebuffer_set_samples_per_pixel()</code>
then you can optionally call this function (or
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-resolve-samples" title="cogl_framebuffer_resolve_samples ()"><code class="function">cogl_framebuffer_resolve_samples()</code></a>) to explicitly resolve the point
samples into values for the final color buffer.
</p>
<p>
Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.
</p>
<p>
Use of this API is recommended if incremental, small updates to
a framebuffer are being made because by default Cogl will
implicitly resolve all the point samples of the framebuffer which
can result in redundant work if only a small number of samples have
changed.
</p>
<p>
Because some GPUs implicitly resolve point samples this function
only guarantees that at-least the region specified will be resolved
and if you have rendered to a larger region then it's possible that
other samples may be implicitly resolved.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> framebuffer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>top-left x coordinate of region to resolve</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>top-left y coordinate of region to resolve</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>width</code></em> :</span></p></td>
<td>width of region to resolve</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>height</code></em> :</span></p></td>
<td>height of region to resolve</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-context"></a><h3>cogl_framebuffer_get_context ()</h3>
<pre class="programlisting"><span class="returnvalue">CoglContext</span> *       cogl_framebuffer_get_context        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-clear"></a><h3>cogl_framebuffer_clear ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_clear              (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">unsigned long </span> buffers</code></em>,
                                                         <em class="parameter"><code>const <a class="link" href="cogl-2.0-experimental-Color-Type.html#CoglColor" title="struct CoglColor"><span class="type">CoglColor</span></a> *color</code></em>);</pre>
<p>
Clears all the auxiliary buffers identified in the <em class="parameter"><code>buffers</code></em> mask, and if
that includes the color buffer then the specified <em class="parameter"><code>color</code></em> is used.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>buffers</code></em> :</span></p></td>
<td>A mask of <a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglBufferBit" title="enum CoglBufferBit"><span class="type">CoglBufferBit</span></a>'s identifying which auxiliary
buffers to clear</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>color</code></em> :</span></p></td>
<td>The color to clear the color buffer too if specified in
<em class="parameter"><code>buffers</code></em>.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-clear4f"></a><h3>cogl_framebuffer_clear4f ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_clear4f            (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">unsigned long </span> buffers</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> red</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> green</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> blue</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> alpha</code></em>);</pre>
<p>
Clears all the auxiliary buffers identified in the <em class="parameter"><code>buffers</code></em> mask, and if
that includes the color buffer then the specified <em class="parameter"><code>color</code></em> is used.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>buffers</code></em> :</span></p></td>
<td>A mask of <a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglBufferBit" title="enum CoglBufferBit"><span class="type">CoglBufferBit</span></a>'s identifying which auxiliary
buffers to clear</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>red</code></em> :</span></p></td>
<td>The red component of color to clear the color buffer too if
specified in <em class="parameter"><code>buffers</code></em>.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>green</code></em> :</span></p></td>
<td>The green component of color to clear the color buffer too if
specified in <em class="parameter"><code>buffers</code></em>.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>blue</code></em> :</span></p></td>
<td>The blue component of color to clear the color buffer too if
specified in <em class="parameter"><code>buffers</code></em>.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpha</code></em> :</span></p></td>
<td>The alpha component of color to clear the color buffer too if
specified in <em class="parameter"><code>buffers</code></em>.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-read-pixels-into-bitmap"></a><h3>cogl_framebuffer_read_pixels_into_bitmap ()</h3>
<pre class="programlisting"><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            cogl_framebuffer_read_pixels_into_bitmap
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-The-Top-Level-Context.html#CoglReadPixelsFlags" title="enum CoglReadPixelsFlags"><span class="type">CoglReadPixelsFlags</span></a> source</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Bitmaps.html#CoglBitmap"><span class="type">CoglBitmap</span></a> *bitmap</code></em>);</pre>
<p>
This reads a rectangle of pixels from the given framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and a rectangle of pixels with the same size as the bitmap is
read right and downwards from that point.
</p>
<p>
Currently Cogl assumes that the framebuffer is in a premultiplied
format so if the format of <em class="parameter"><code>bitmap</code></em> is non-premultiplied it will
convert it. To read the pixel values without any conversion you
should either specify a format that doesn't use an alpha channel or
use one of the formats ending in PRE.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>The x position to read from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>The y position to read from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em> :</span></p></td>
<td>Identifies which auxillary buffer you want to read
(only COGL_READ_PIXELS_COLOR_BUFFER supported currently)</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bitmap</code></em> :</span></p></td>
<td>The bitmap to store the results in.</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>
<a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> if the read succeeded or <a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a> otherwise. The
function is only likely to fail if the bitmap points to a pixel
buffer and it could not be mapped.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-read-pixels"></a><h3>cogl_framebuffer_read_pixels ()</h3>
<pre class="programlisting"><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            cogl_framebuffer_read_pixels        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> height</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglPixelFormat" title="enum CoglPixelFormat"><span class="type">CoglPixelFormat</span></a> format</code></em>,
                                                         <em class="parameter"><code><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#guint8"><span class="type">guint8</span></a> *pixels</code></em>);</pre>
<p>
This is a convenience wrapper around
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-read-pixels-into-bitmap" title="cogl_framebuffer_read_pixels_into_bitmap ()"><code class="function">cogl_framebuffer_read_pixels_into_bitmap()</code></a> which allocates a
temporary <a href="../cogl/cogl-Bitmaps.html#CoglBitmap"><span class="type">CoglBitmap</span></a> to read pixel data directly into the given
buffer. The rowstride of the buffer is assumed to be the width of
the region times the bytes per pixel of the format. The source for
the data is always taken from the color buffer. If you want to use
any other rowstride or source, please use the
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-read-pixels-into-bitmap" title="cogl_framebuffer_read_pixels_into_bitmap ()"><code class="function">cogl_framebuffer_read_pixels_into_bitmap()</code></a> function directly.
</p>
<p>
The implementation of the function looks like this:
</p>
<p>
</p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="normal">bitmap </span><span class="symbol">=</span><span class="normal"> </span><span class="function">cogl_bitmap_new_for_data</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">context</span><span class="symbol">,</span>
<span class="normal">                                   width</span><span class="symbol">,</span><span class="normal"> height</span><span class="symbol">,</span>
<span class="normal">                                   format</span><span class="symbol">,</span>
<span class="normal">                                   </span><span class="comment">/* rowstride */</span>
<span class="normal">                                   bpp </span><span class="symbol">*</span><span class="normal"> width</span><span class="symbol">,</span>
<span class="normal">                                   pixels</span><span class="symbol">);</span>
<span class="function"><a href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-read-pixels-into-bitmap">cogl_framebuffer_read_pixels_into_bitmap</a></span><span class="normal"> </span><span class="symbol">(</span><span class="normal">framebuffer</span><span class="symbol">,</span>
<span class="normal">                                          x</span><span class="symbol">,</span><span class="normal"> y</span><span class="symbol">,</span>
<span class="normal">                                          <a href="cogl-2.0-experimental-The-Top-Level-Context.html#COGL-READ-PIXELS-COLOR-BUFFER:CAPS">COGL_READ_PIXELS_COLOR_BUFFER</a></span><span class="symbol">,</span>
<span class="normal">                                          bitmap</span><span class="symbol">);</span>
<span class="function"><a href="cogl-2.0-experimental-The-Object-Interface.html#cogl-object-unref">cogl_object_unref</a></span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bitmap</span><span class="symbol">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>The x position to read from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>The y position to read from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>width</code></em> :</span></p></td>
<td>The width of the region of rectangles to read</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>height</code></em> :</span></p></td>
<td>The height of the region of rectangles to read</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>format</code></em> :</span></p></td>
<td>The pixel format to store the data in</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pixels</code></em> :</span></p></td>
<td>The address of the buffer to store the data in</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>
<a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> if the read succeeded or <a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a> otherwise.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-set-dither-enabled"></a><h3>cogl_framebuffer_set_dither_enabled ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_set_dither_enabled (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="type">gboolean</span></a> dither_enabled</code></em>);</pre>
<p>
Enables or disabled dithering if supported by the hardware.
</p>
<p>
Dithering is a hardware dependent technique to increase the visible
color resolution beyond what the underlying hardware supports by playing
tricks with the colors placed into the framebuffer to give the illusion
of other colors. (For example this can be compared to half-toning used
by some news papers to show varying levels of grey even though their may
only be black and white are available).
</p>
<p>
If the current display pipeline for <em class="parameter"><code>framebuffer</code></em> does not support dithering
then this has no affect.
</p>
<p>
Dithering is enabled by default.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>a pointer to a <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dither_enabled</code></em> :</span></p></td>
<td>
<a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> to enable dithering or <a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a> to disable</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-dither-enabled"></a><h3>cogl_framebuffer_get_dither_enabled ()</h3>
<pre class="programlisting"><a href="http://library.gnome.org/devel/glib/unstable/glib-Basic-Types.html#gboolean"><span class="returnvalue">gboolean</span></a>            cogl_framebuffer_get_dither_enabled (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Returns whether dithering has been requested for the given <em class="parameter"><code>framebuffer</code></em>.
See <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-set-dither-enabled" title="cogl_framebuffer_set_dither_enabled ()"><code class="function">cogl_framebuffer_set_dither_enabled()</code></a> for more details about dithering.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>This may return <a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> even when the underlying <em class="parameter"><code>framebuffer</code></em>
display pipeline does not support dithering. This value only represents
the user's request for dithering.</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>a pointer to a <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>
<a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> if dithering has been requested or <a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a> if not.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-primitive"></a><h3>cogl_framebuffer_draw_primitive ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_primitive     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Primitives.html#CoglPrimitive" title="CoglPrimitive"><span class="type">CoglPrimitive</span></a> *primitive</code></em>);</pre>
<p>
Draws the given <em class="parameter"><code>primitive</code></em> geometry to the specified destination
<em class="parameter"><code>framebuffer</code></em> using the graphics processing state described by <em class="parameter"><code>pipeline</code></em>.
</p>
<p>
This drawing api doesn't support high-level meta texture types such
as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as <a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>, <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> or <a class="link" href="cogl-2.0-experimental-3D-textures.html#CoglTexture3D" title="CoglTexture3D"><span class="type">CoglTexture3D</span></a>
are associated with layers of the given <em class="parameter"><code>pipeline</code></em>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>This api doesn't support any of the legacy global state options such
as <a href="../cogl/cogl-General-API-(Deprecated).html#cogl-set-depth-test-enabled"><code class="function">cogl_set_depth_test_enabled()</code></a>, <a href="../cogl/cogl-General-API.html#cogl-set-backface-culling-enabled"><code class="function">cogl_set_backface_culling_enabled()</code></a> or
<a href="../cogl/cogl-Shaders-and-Programmable-Pipeline-(Deprecated).html#cogl-program-use"><code class="function">cogl_program_use()</code></a>
</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>primitive</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-Primitives.html#CoglPrimitive" title="CoglPrimitive"><span class="type">CoglPrimitive</span></a> geometry object</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-attributes"></a><h3>cogl_framebuffer_draw_attributes ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_attributes    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglAttribute</span> **attributes</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_attributes</code></em>);</pre>
<p>
First defines a geometry primitive by grouping a set of vertex <em class="parameter"><code>attributes</code></em>;
specifying a <em class="parameter"><code>first_vertex</code></em>; a number of vertices (<em class="parameter"><code>n_vertices</code></em>) and
specifying  what kind of topology the vertices have via <em class="parameter"><code>mode</code></em>.
</p>
<p>
Then the function draws the given <em class="parameter"><code>primitive</code></em> geometry to the specified
destination <em class="parameter"><code>framebuffer</code></em> using the graphics processing pipeline described by
<em class="parameter"><code>pipeline</code></em>.
</p>
<p>
The list of <span class="type">CoglAttribute</span>s define the attributes of the vertices to
be drawn, such as positions, colors and normals and the number of attributes
is given as <em class="parameter"><code>n_attributes</code></em>.
</p>
<p>
This drawing api doesn't support high-level meta texture types such
as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as <a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>, <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> or <a class="link" href="cogl-2.0-experimental-3D-textures.html#CoglTexture3D" title="CoglTexture3D"><span class="type">CoglTexture3D</span></a>
are associated with layers of the given <em class="parameter"><code>pipeline</code></em>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>This api doesn't support any of the legacy global state options such
as <a href="../cogl/cogl-General-API-(Deprecated).html#cogl-set-depth-test-enabled"><code class="function">cogl_set_depth_test_enabled()</code></a>, <a href="../cogl/cogl-General-API.html#cogl-set-backface-culling-enabled"><code class="function">cogl_set_backface_culling_enabled()</code></a> or
<a href="../cogl/cogl-Shaders-and-Programmable-Pipeline-(Deprecated).html#cogl-program-use"><code class="function">cogl_program_use()</code></a>
</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em> :</span></p></td>
<td>The <a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> defining the topology of vertices</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>first_vertex</code></em> :</span></p></td>
<td>The vertex offset within the given attributes to draw from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_vertices</code></em> :</span></p></td>
<td>The number of vertices to draw from the given attributes</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>attributes</code></em> :</span></p></td>
<td>An array of pointers to <span class="type">CoglAttribute</span>&lt;-- --&gt;s defining vertex
geometry</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_attributes</code></em> :</span></p></td>
<td>The number of attributes in the <em class="parameter"><code>attributes</code></em> array.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-vdraw-attributes"></a><h3>cogl_framebuffer_vdraw_attributes ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_vdraw_attributes   (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code>...</code></em>);</pre>
<p>
First defines a geometry primitive by grouping a set of vertex attributes;
specifying a <em class="parameter"><code>first_vertex</code></em>; a number of vertices (<em class="parameter"><code>n_vertices</code></em>) and
specifying  what kind of topology the vertices have via <em class="parameter"><code>mode</code></em>.
</p>
<p>
Then the function draws the given <em class="parameter"><code>primitive</code></em> geometry to the specified
destination <em class="parameter"><code>framebuffer</code></em> using the graphics processing pipeline described by
<em class="parameter"><code>pipeline</code></em>.
</p>
<p>
The list of <span class="type">CoglAttribute</span>s define the attributes of the vertices to
be drawn, such as positions, colors and normals and should be <a href="http://library.gnome.org/devel/glib/unstable/glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>
terminated.
</p>
<p>
This drawing api doesn't support high-level meta texture types such
as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as <a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>, <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> or <a class="link" href="cogl-2.0-experimental-3D-textures.html#CoglTexture3D" title="CoglTexture3D"><span class="type">CoglTexture3D</span></a>
are associated with layers of the given <em class="parameter"><code>pipeline</code></em>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em> :</span></p></td>
<td>The <a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> defining the topology of vertices</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>first_vertex</code></em> :</span></p></td>
<td>The vertex offset within the given attributes to draw from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_vertices</code></em> :</span></p></td>
<td>The number of vertices to draw from the given attributes</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>...</code></em> :</span></p></td>
<td>A set of vertex <span class="type">CoglAttribute</span>s defining vertex geometry</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-indexed-attributes"></a><h3>cogl_framebuffer_draw_indexed_attributes ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_indexed_attributes
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglIndices</span> *indices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglAttribute</span> **attributes</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_attributes</code></em>);</pre>
<p>
Behaves the same as <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-attributes" title="cogl_framebuffer_draw_attributes ()"><code class="function">cogl_framebuffer_draw_attributes()</code></a> except that
instead of reading vertex data sequentially from the specified
<em class="parameter"><code>attributes</code></em> the <em class="parameter"><code>indices</code></em> provide an indirection for how the data
should be indexed allowing a random access order to be
specified.
</p>
<p>
For example an indices array of [0, 1, 2, 0, 2, 3] could be used
used to draw two triangles (<em class="parameter"><code>mode</code></em> = <a href="../cogl/cogl-Vertex-Buffers.html#COGL-VERTICES-MODE-TRIANGLES:CAPS"><code class="literal">COGL_VERTICES_MODE_TRIANGLES</code></a> +
<em class="parameter"><code>n_vertices</code></em> = 6) but only provide attribute data for the 4 corners
of a rectangle. When the GPU needs to read in each of the 6
vertices it will read the <em class="parameter"><code>indices</code></em> array for each vertex in
sequence and use the index to look up the vertex attribute data. So
here you can see that first and fourth vertex will point to the
same data and third and fifth vertex will also point to shared
data.
</p>
<p>
Drawing with indices can be a good way of minimizing the size of a
mesh by allowing you to avoid data for duplicate vertices because
multiple entries in the index array can refer back to a single
shared vertex.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The <em class="parameter"><code>indices</code></em> array must be at least as long as <em class="parameter"><code>first_vertex</code></em>
+ <em class="parameter"><code>n_vertices</code></em> otherwise the GPU will overrun the indices array when
looking up vertex data.</div>
<p>
</p>
<p>
Since it's very common to want to draw a run of rectangles using
indices to avoid duplicating vertex data you can use
<code class="function">cogl_get_rectangle_indices()</code> to get a set of indices that can be
shared.
</p>
<p>
This drawing api doesn't support high-level meta texture types such
as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as <a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>, <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> or
<a class="link" href="cogl-2.0-experimental-3D-textures.html#CoglTexture3D" title="CoglTexture3D"><span class="type">CoglTexture3D</span></a> are associated with layers of the given <em class="parameter"><code>pipeline</code></em>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>This api doesn't support any of the legacy global state
options such as <a href="../cogl/cogl-General-API-(Deprecated).html#cogl-set-depth-test-enabled"><code class="function">cogl_set_depth_test_enabled()</code></a>,
<a href="../cogl/cogl-General-API.html#cogl-set-backface-culling-enabled"><code class="function">cogl_set_backface_culling_enabled()</code></a> or <a href="../cogl/cogl-Shaders-and-Programmable-Pipeline-(Deprecated).html#cogl-program-use"><code class="function">cogl_program_use()</code></a>
</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em> :</span></p></td>
<td>The <a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> defining the topology of vertices</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>first_vertex</code></em> :</span></p></td>
<td>The vertex offset within the given attributes to draw from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_vertices</code></em> :</span></p></td>
<td>The number of vertices to draw from the given attributes</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>indices</code></em> :</span></p></td>
<td>The array of indices used by the GPU to lookup attribute
data for each vertex.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>attributes</code></em> :</span></p></td>
<td>An array of pointers to <span class="type">CoglAttribute</span>&lt;-- --&gt;s defining vertex
geometry</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_attributes</code></em> :</span></p></td>
<td>The number of attributes in the <em class="parameter"><code>attributes</code></em> array.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-vdraw-indexed-attributes"></a><h3>cogl_framebuffer_vdraw_indexed_attributes ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_vdraw_indexed_attributes
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> mode</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> first_vertex</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_vertices</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglIndices</span> *indices</code></em>,
                                                         <em class="parameter"><code>...</code></em>);</pre>
<p>
Behaves the same as <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-vdraw-attributes" title="cogl_framebuffer_vdraw_attributes ()"><code class="function">cogl_framebuffer_vdraw_attributes()</code></a> except that
instead of reading vertex data sequentially from the specified
attributes the <em class="parameter"><code>indices</code></em> provide an indirection for how the data
should be indexed allowing a random access order to be
specified.
</p>
<p>
For example an indices array of [0, 1, 2, 0, 2, 3] could be used
used to draw two triangles (<em class="parameter"><code>mode</code></em> = <a href="../cogl/cogl-Vertex-Buffers.html#COGL-VERTICES-MODE-TRIANGLES:CAPS"><code class="literal">COGL_VERTICES_MODE_TRIANGLES</code></a> +
<em class="parameter"><code>n_vertices</code></em> = 6) but only provide attribute data for the 4 corners
of a rectangle. When the GPU needs to read in each of the 6
vertices it will read the <em class="parameter"><code>indices</code></em> array for each vertex in
sequence and use the index to look up the vertex attribute data. So
here you can see that first and fourth vertex will point to the
same data and third and fifth vertex will also point to shared
data.
</p>
<p>
Drawing with indices can be a good way of minimizing the size of a
mesh by allowing you to avoid data for duplicate vertices because
multiple entries in the index array can refer back to a single
shared vertex.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The <em class="parameter"><code>indices</code></em> array must be at least as long as <em class="parameter"><code>first_vertex</code></em>
+ <em class="parameter"><code>n_vertices</code></em> otherwise the GPU will overrun the indices array when
looking up vertex data.</div>
<p>
</p>
<p>
Since it's very common to want to draw a run of rectangles using
indices to avoid duplicating vertex data you can use
<code class="function">cogl_get_rectangle_indices()</code> to get a set of indices that can be
shared.
</p>
<p>
This drawing api doesn't support high-level meta texture types such
as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as <a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>, <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> or
<a class="link" href="cogl-2.0-experimental-3D-textures.html#CoglTexture3D" title="CoglTexture3D"><span class="type">CoglTexture3D</span></a> are associated with layers of the given <em class="parameter"><code>pipeline</code></em>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>This api doesn't support any of the legacy global state
options such as <a href="../cogl/cogl-General-API-(Deprecated).html#cogl-set-depth-test-enabled"><code class="function">cogl_set_depth_test_enabled()</code></a>,
<a href="../cogl/cogl-General-API.html#cogl-set-backface-culling-enabled"><code class="function">cogl_set_backface_culling_enabled()</code></a> or <a href="../cogl/cogl-Shaders-and-Programmable-Pipeline-(Deprecated).html#cogl-program-use"><code class="function">cogl_program_use()</code></a>
</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em> :</span></p></td>
<td>The <a href="../cogl/cogl-Vertex-Buffers.html#CoglVerticesMode"><span class="type">CoglVerticesMode</span></a> defining the topology of vertices</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>first_vertex</code></em> :</span></p></td>
<td>The vertex offset within the given attributes to draw from</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_vertices</code></em> :</span></p></td>
<td>The number of vertices to draw from the given attributes</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>indices</code></em> :</span></p></td>
<td>The array of indices used by the GPU to lookup attribute
data for each vertex.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>...</code></em> :</span></p></td>
<td>A set of vertex <span class="type">CoglAttribute</span>s defining vertex geometry</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-rectangle"></a><h3>cogl_framebuffer_draw_rectangle ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_rectangle     (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>);</pre>
<p>
Draws a rectangle to <em class="parameter"><code>framebuffer</code></em> with the given <em class="parameter"><code>pipeline</code></em> state
and with the top left corner positioned at (<em class="parameter"><code>x_1</code></em>, <em class="parameter"><code>y_1</code></em>) and the
bottom right corner positioned at (<em class="parameter"><code>x_2</code></em>, <em class="parameter"><code>y_2</code></em>).
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.</div>
<p>
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>If you want to describe a rectangle with a texture mapped on
it then you can use
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-textured-rectangle" title="cogl_framebuffer_draw_textured_rectangle ()"><code class="function">cogl_framebuffer_draw_textured_rectangle()</code></a>.</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_1</code></em> :</span></p></td>
<td>X coordinate of the top-left corner</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_1</code></em> :</span></p></td>
<td>Y coordinate of the top-left corner</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_2</code></em> :</span></p></td>
<td>X coordinate of the bottom-right corner</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_2</code></em> :</span></p></td>
<td>Y coordinate of the bottom-right corner</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-textured-rectangle"></a><h3>cogl_framebuffer_draw_textured_rectangle ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_textured_rectangle
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> s_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> t_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> s_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> t_2</code></em>);</pre>
<p>
Draws a textured rectangle to <em class="parameter"><code>framebuffer</code></em> using the given
<em class="parameter"><code>pipeline</code></em> state with the top left corner positioned at (<em class="parameter"><code>x_1</code></em>, <em class="parameter"><code>y_1</code></em>)
and the bottom right corner positioned at (<em class="parameter"><code>x_2</code></em>, <em class="parameter"><code>y_2</code></em>). The top
left corner will have texture coordinates of (<em class="parameter"><code>s_1</code></em>, <em class="parameter"><code>t_1</code></em>) and the
bottom right corner will have texture coordinates of (<em class="parameter"><code>s_2</code></em>, <em class="parameter"><code>t_2</code></em>).
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.</div>
<p>
</p>
<p>
This is a high level drawing api that can handle any kind of
<a class="link" href="cogl-2.0-experimental-High-Level-Meta-Textures.html#CoglMetaTexture" title="CoglMetaTexture"><span class="type">CoglMetaTexture</span></a> texture such as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-primitive" title="cogl_framebuffer_draw_primitive ()"><code class="function">cogl_framebuffer_draw_primitive()</code></a> or
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-attributes" title="cogl_framebuffer_draw_attributes ()"><code class="function">cogl_framebuffer_draw_attributes()</code></a> which only support low level
texture types that are directly supported by GPUs such as
<a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The given texture coordinates will only be used for the first
texture layer of the pipeline and if your pipeline has more than
one layer then all other layers will have default texture
coordinates of <em class="parameter"><code>s_1</code></em>=0.0 <em class="parameter"><code>t_1</code></em>=0.0 <em class="parameter"><code>s_2</code></em>=1.0 <em class="parameter"><code>t_2</code></em>=1.0 </div>
<p>
</p>
<p>
The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in <em class="parameter"><code>s_1</code></em>=<code class="literal">0</code>, <em class="parameter"><code>t_1</code></em>=<code class="literal">0</code>, <em class="parameter"><code>s_2</code></em>=<code class="literal">1</code>, <em class="parameter"><code>t_2</code></em>=<code class="literal">1</code>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>Even if you have associated a <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> texture
with one of your <em class="parameter"><code>pipeline</code></em> layers which normally implies working
with non-normalized texture coordinates this api should still be
passed normalized texture coordinates.</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_1</code></em> :</span></p></td>
<td>x coordinate upper left on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_1</code></em> :</span></p></td>
<td>y coordinate upper left on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_2</code></em> :</span></p></td>
<td>x coordinate lower right on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_2</code></em> :</span></p></td>
<td>y coordinate lower right on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>s_1</code></em> :</span></p></td>
<td>S texture coordinate of the top-left coorner</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>t_1</code></em> :</span></p></td>
<td>T texture coordinate of the top-left coorner</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>s_2</code></em> :</span></p></td>
<td>S texture coordinate of the bottom-right coorner</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>t_2</code></em> :</span></p></td>
<td>T texture coordinate of the bottom-right coorner</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-multitextured-rectangle"></a><h3>cogl_framebuffer_draw_multitextured_rectangle ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_multitextured_rectangle
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>,
                                                         <em class="parameter"><code>const <span class="type">float</span> *tex_coords</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> tex_coords_len</code></em>);</pre>
<p>
Draws a textured rectangle to <em class="parameter"><code>framebuffer</code></em> with the given <em class="parameter"><code>pipeline</code></em>
state with the top left corner positioned at (<em class="parameter"><code>x_1</code></em>, <em class="parameter"><code>y_1</code></em>) and the
bottom right corner positioned at (<em class="parameter"><code>x_2</code></em>, <em class="parameter"><code>y_2</code></em>). As a pipeline may
contain multiple texture layers this interface lets you supply
texture coordinates for each layer of the pipeline.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.</div>
<p>
</p>
<p>
This is a high level drawing api that can handle any kind of
<a class="link" href="cogl-2.0-experimental-High-Level-Meta-Textures.html#CoglMetaTexture" title="CoglMetaTexture"><span class="type">CoglMetaTexture</span></a> texture for the first layer such as
<a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> textures which may internally be comprised of
multiple low-level textures.  This is unlike low-level drawing apis
such as <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-primitive" title="cogl_framebuffer_draw_primitive ()"><code class="function">cogl_framebuffer_draw_primitive()</code></a> or
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-attributes" title="cogl_framebuffer_draw_attributes ()"><code class="function">cogl_framebuffer_draw_attributes()</code></a> which only support low level
texture types that are directly supported by GPUs such as
<a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>This api can not currently handle multiple high-level meta
texture layers. The first layer may be a high level meta texture
such as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> but all other layers much be low
level textures such as <a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a> and additionally they
should be textures that can be sampled using normalized coordinates
(so not <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> textures).</div>
<p>
</p>
<p>
The top left texture coordinate for layer 0 of any pipeline will be
(tex_coords[0], tex_coords[1]) and the bottom right coordinate will
be (tex_coords[2], tex_coords[3]). The coordinates for layer 1
would be (tex_coords[4], tex_coords[5]) (tex_coords[6],
tex_coords[7]) and so on...
</p>
<p>
The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=<code class="literal">0</code>, tex_coords[1]=<code class="literal">0</code>, tex_coords[2]=<code class="literal">1</code>,
tex_coords[3]=<code class="literal">1</code>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>Even if you have associated a <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> texture
which normally implies working with non-normalized texture
coordinates this api should still be passed normalized texture
coordinates.</div>
<p>
</p>
<p>
The first pair of coordinates are for the first layer (with the
smallest layer index) and if you supply less texture coordinates
than there are layers in the current source material then default
texture coordinates (0.0, 0.0, 1.0, 1.0) are generated.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_1</code></em> :</span></p></td>
<td>x coordinate upper left on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_1</code></em> :</span></p></td>
<td>y coordinate upper left on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_2</code></em> :</span></p></td>
<td>x coordinate lower right on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_2</code></em> :</span></p></td>
<td>y coordinate lower right on screen.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tex_coords</code></em> :</span></p></td>
<td>An array containing groups of
4 float values: [s_1, t_1, s_2, t_2] that are interpreted as two texture
coordinates; one for the top left texel, and one for the bottom right
texel. Each value should be between 0.0 and 1.0, where the coordinate
(0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the
bottom right. <span class="annotation">[<acronym title="Parameter for input. Default is transfer none."><span class="acronym">in</span></acronym>][<acronym title="Parameter points to an array of items."><span class="acronym">array</span></acronym>][<acronym title="Don't free data after the code is done."><span class="acronym">transfer none</span></acronym>]</span>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tex_coords_len</code></em> :</span></p></td>
<td>The length of the <em class="parameter"><code>tex_coords</code></em> array. (For one layer
and one group of texture coordinates, this would be 4)</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-rectangles"></a><h3>cogl_framebuffer_draw_rectangles ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_rectangles    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code>const <span class="type">float</span> *verts</code></em>,
                                                         <em class="parameter"><code>unsigned <span class="type">int</span> n_rects</code></em>);</pre>
<p>
Draws a series of rectangles to <em class="parameter"><code>framebuffer</code></em> with the given
<em class="parameter"><code>pipeline</code></em> state in the same way that
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-rectangle" title="cogl_framebuffer_draw_rectangle ()"><code class="function">cogl_framebuffer_draw_rectangle()</code></a> does.
</p>
<p>
The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The positions for
the second rectangle are (coordinates[4], coordinates[5]) and
(coordinates[6], coordinates[7]) and so on...
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.</div>
<p>
</p>
<p>
As a general rule for better performance its recommended to use
this this API instead of calling
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-textured-rectangle" title="cogl_framebuffer_draw_textured_rectangle ()"><code class="function">cogl_framebuffer_draw_textured_rectangle()</code></a> separately for multiple
rectangles if all of the rectangles will be drawn together with the
same <em class="parameter"><code>pipeline</code></em> state.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>coordinates</code></em> :</span></p></td>
<td>an array of coordinates
containing groups of 4 float values: [x_1, y_1, x_2, y_2] that are
interpreted as two position coordinates; one for the top left of
the rectangle (x1, y1), and one for the bottom right of the
rectangle (x2, y2). <span class="annotation">[<acronym title="Parameter for input. Default is transfer none."><span class="acronym">in</span></acronym>][<acronym title="Parameter points to an array of items."><span class="acronym">array</span></acronym>][<acronym title="Don't free data after the code is done."><span class="acronym">transfer none</span></acronym>]</span>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_rectangles</code></em> :</span></p></td>
<td>number of rectangles defined in <em class="parameter"><code>coordinates</code></em>.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-draw-textured-rectangles"></a><h3>cogl_framebuffer_draw_textured_rectangles ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_draw_textured_rectangles
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">CoglPipeline</span> *pipeline</code></em>,
                                                         <em class="parameter"><code>const <span class="type">float</span> *coordinates</code></em>,
                                                         <em class="parameter"><code>unsigned <span class="type">int</span> n_rectangles</code></em>);</pre>
<p>
Draws a series of rectangles to <em class="parameter"><code>framebuffer</code></em> with the given
<em class="parameter"><code>pipeline</code></em> state in the same way that
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-textured-rectangle" title="cogl_framebuffer_draw_textured_rectangle ()"><code class="function">cogl_framebuffer_draw_textured_rectangle()</code></a> does.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.</div>
<p>
</p>
<p>
This is a high level drawing api that can handle any kind of
<a class="link" href="cogl-2.0-experimental-High-Level-Meta-Textures.html#CoglMetaTexture" title="CoglMetaTexture"><span class="type">CoglMetaTexture</span></a> texture such as <a class="link" href="cogl-2.0-experimental-Sliced-Textures.html#CoglTexture2DSliced" title="CoglTexture2DSliced"><span class="type">CoglTexture2DSliced</span></a> textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-primitive" title="cogl_framebuffer_draw_primitive ()"><code class="function">cogl_framebuffer_draw_primitive()</code></a> or
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-attributes" title="cogl_framebuffer_draw_attributes ()"><code class="function">cogl_framebuffer_draw_attributes()</code></a> which only support low level
texture types that are directly supported by GPUs such as
<a class="link" href="cogl-2.0-experimental-2D-textures.html#CoglTexture2D" title="CoglTexture2D"><span class="type">CoglTexture2D</span></a>.
</p>
<p>
The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The top left
texture coordinate is (coordinates[4], coordinates[5]) and the
bottom right texture coordinate is (coordinates[6],
coordinates[7]). The coordinates for subsequent rectangles
are defined similarly by the subsequent coordinates.
</p>
<p>
As a general rule for better performance its recommended to use
this this API instead of calling
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-textured-rectangle" title="cogl_framebuffer_draw_textured_rectangle ()"><code class="function">cogl_framebuffer_draw_textured_rectangle()</code></a> separately for multiple
rectangles if all of the rectangles will be drawn together with the
same <em class="parameter"><code>pipeline</code></em> state.
</p>
<p>
The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=<code class="literal">0</code>, tex_coords[1]=<code class="literal">0</code>, tex_coords[2]=<code class="literal">1</code>,
tex_coords[3]=<code class="literal">1</code>.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>Even if you have associated a <a class="link" href="cogl-2.0-experimental-Rectangle-textures-(non-normalized-coordinates).html#CoglTextureRectangle" title="CoglTextureRectangle"><span class="type">CoglTextureRectangle</span></a> texture
which normally implies working with non-normalized texture
coordinates this api should still be passed normalized texture
coordinates.</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A destination <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pipeline</code></em> :</span></p></td>
<td>A <span class="type">CoglPipeline</span> state object</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>coordinates</code></em> :</span></p></td>
<td>an array containing
groups of 8 float values: [x_1, y_1, x_2, y_2, s_1, t_1, s_2, t_2]
that have the same meaning as the arguments for
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-draw-textured-rectangle" title="cogl_framebuffer_draw_textured_rectangle ()"><code class="function">cogl_framebuffer_draw_textured_rectangle()</code></a>. <span class="annotation">[<acronym title="Parameter for input. Default is transfer none."><span class="acronym">in</span></acronym>][<acronym title="Parameter points to an array of items."><span class="acronym">array</span></acronym>][<acronym title="Don't free data after the code is done."><span class="acronym">transfer none</span></acronym>]</span>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_rectangles</code></em> :</span></p></td>
<td>number of rectangles to <em class="parameter"><code>coordinates</code></em> to draw</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-finish"></a><h3>cogl_framebuffer_finish ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_finish             (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
This blocks the CPU until all pending rendering associated with the
specified framebuffer has completed. It's very rare that developers should
ever need this level of synchronization with the GPU and should never be
used unless you clearly understand why you need to explicitly force
synchronization.
</p>
<p>
One example might be for benchmarking purposes to be sure timing
measurements reflect the time that the GPU is busy for not just the time it
takes to queue rendering commands.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-push-matrix"></a><h3>cogl_framebuffer_push_matrix ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_push_matrix        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Copies the current model-view matrix onto the matrix stack. The matrix
can later be restored with <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-pop-matrix" title="cogl_framebuffer_pop_matrix ()"><code class="function">cogl_framebuffer_pop_matrix()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.10</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-pop-matrix"></a><h3>cogl_framebuffer_pop_matrix ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_pop_matrix         (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Restores the model-view matrix on the top of the matrix stack.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.10</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-identity-matrix"></a><h3>cogl_framebuffer_identity_matrix ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_identity_matrix    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Resets the current model-view matrix to the identity matrix.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-scale"></a><h3>cogl_framebuffer_scale ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_scale              (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z</code></em>);</pre>
<p>
Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>Amount to scale along the x-axis</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>Amount to scale along the y-axis</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>z</code></em> :</span></p></td>
<td>Amount to scale along the z-axis</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-translate"></a><h3>cogl_framebuffer_translate ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_translate          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z</code></em>);</pre>
<p>
Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>Distance to translate along the x-axis</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>Distance to translate along the y-axis</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>z</code></em> :</span></p></td>
<td>Distance to translate along the z-axis</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-rotate"></a><h3>cogl_framebuffer_rotate ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_rotate             (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> angle</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z</code></em>);</pre>
<p>
Multiplies the current model-view matrix by one that rotates the
model around the vertex specified by <em class="parameter"><code>x</code></em>, <em class="parameter"><code>y</code></em> and <em class="parameter"><code>z</code></em>. The rotation
follows the right-hand thumb rule so for example rotating by 10
degrees about the vertex (0, 0, 1) causes a small counter-clockwise
rotation.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>angle</code></em> :</span></p></td>
<td>Angle in degrees to rotate.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>X-component of vertex to rotate around.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>Y-component of vertex to rotate around.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>z</code></em> :</span></p></td>
<td>Z-component of vertex to rotate around.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-transform"></a><h3>cogl_framebuffer_transform ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_transform          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code>const <a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);</pre>
<p>
Multiplies the current model-view matrix by the given matrix.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em> :</span></p></td>
<td>the matrix to multiply with the current model-view</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-modelview-matrix"></a><h3>cogl_framebuffer_get_modelview_matrix ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_get_modelview_matrix
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);</pre>
<p>
Stores the current model-view matrix in <em class="parameter"><code>matrix</code></em>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em> :</span></p></td>
<td>return location for the model-view matrix. <span class="annotation">[<acronym title="Parameter for returning results. Default is transfer full."><span class="acronym">out</span></acronym>]</span>
</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-set-modelview-matrix"></a><h3>cogl_framebuffer_set_modelview_matrix ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_set_modelview_matrix
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);</pre>
<p>
Sets <em class="parameter"><code>matrix</code></em> as the new model-view matrix.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em> :</span></p></td>
<td>the new model-view matrix</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-perspective"></a><h3>cogl_framebuffer_perspective ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_perspective        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> fov_y</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> aspect</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_near</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_far</code></em>);</pre>
<p>
Replaces the current projection matrix with a perspective matrix
based on the provided values.
</p>
<p>
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>You should be careful not to have to great a <em class="parameter"><code>z_far</code></em> / <em class="parameter"><code>z_near</code></em>
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fov_y</code></em> :</span></p></td>
<td>Vertical field of view angle in degrees.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>aspect</code></em> :</span></p></td>
<td>The (width over height) aspect ratio for display</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>z_near</code></em> :</span></p></td>
<td>The distance to the near clipping plane (Must be positive,
and must not be 0)</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>z_far</code></em> :</span></p></td>
<td>The distance to the far clipping plane (Must be positive)</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-frustum"></a><h3>cogl_framebuffer_frustum ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_frustum            (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> left</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> right</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bottom</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> top</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_near</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> z_far</code></em>);</pre>
<p>
Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>left</code></em> :</span></p></td>
<td>X position of the left clipping plane where it
intersects the near clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>right</code></em> :</span></p></td>
<td>X position of the right clipping plane where it
intersects the near clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bottom</code></em> :</span></p></td>
<td>Y position of the bottom clipping plane where it
intersects the near clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>top</code></em> :</span></p></td>
<td>Y position of the top clipping plane where it intersects
the near clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>z_near</code></em> :</span></p></td>
<td>The distance to the near clipping plane (Must be positive)</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>z_far</code></em> :</span></p></td>
<td>The distance to the far clipping plane (Must be positive)</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-orthographic"></a><h3>cogl_framebuffer_orthographic ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_orthographic       (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> near</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> far</code></em>);</pre>
<p>
Replaces the current projection matrix with an orthographic projection
matrix.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_1</code></em> :</span></p></td>
<td>The x coordinate for the first vertical clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_1</code></em> :</span></p></td>
<td>The y coordinate for the first horizontal clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_2</code></em> :</span></p></td>
<td>The x coordinate for the second vertical clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_2</code></em> :</span></p></td>
<td>The y coordinate for the second horizontal clipping plane</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>near</code></em> :</span></p></td>
<td>The <span class="emphasis"><em>distance</em></span> to the near clipping
plane (will be <span class="emphasis"><em>negative</em></span> if the plane is
behind the viewer)</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>far</code></em> :</span></p></td>
<td>The <span class="emphasis"><em>distance</em></span> to the far clipping
plane (will be <span class="emphasis"><em>negative</em></span> if the plane is
behind the viewer)</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-get-projection-matrix"></a><h3>cogl_framebuffer_get_projection_matrix ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_get_projection_matrix
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);</pre>
<p>
Stores the current projection matrix in <em class="parameter"><code>matrix</code></em>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em> :</span></p></td>
<td>return location for the projection matrix. <span class="annotation">[<acronym title="Parameter for returning results. Default is transfer full."><span class="acronym">out</span></acronym>]</span>
</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-set-projection-matrix"></a><h3>cogl_framebuffer_set_projection_matrix ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_set_projection_matrix
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Matrices.html#CoglMatrix" title="CoglMatrix"><span class="type">CoglMatrix</span></a> *matrix</code></em>);</pre>
<p>
Sets <em class="parameter"><code>matrix</code></em> as the new projection matrix.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em> :</span></p></td>
<td>the new projection matrix</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-push-scissor-clip"></a><h3>cogl_framebuffer_push_scissor_clip ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_push_scissor_clip  (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> x</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> y</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> width</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> height</code></em>);</pre>
<p>
Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.
</p>
<p>
The rectangle is intersected with the current clip region. To undo
the effect of this function, call <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-pop-clip" title="cogl_framebuffer_pop_clip ()"><code class="function">cogl_framebuffer_pop_clip()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em> :</span></p></td>
<td>left edge of the clip rectangle in window coordinates</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em> :</span></p></td>
<td>top edge of the clip rectangle in window coordinates</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>width</code></em> :</span></p></td>
<td>width of the clip rectangle</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>height</code></em> :</span></p></td>
<td>height of the clip rectangle</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-push-rectangle-clip"></a><h3>cogl_framebuffer_push_rectangle_clip ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_push_rectangle_clip
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> x_2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> y_2</code></em>);</pre>
<p>
Specifies a modelview transformed rectangular clipping area for all
subsequent drawing operations. Any drawing commands that extend
outside the rectangle will be clipped so that only the portion
inside the rectangle will be displayed. The rectangle dimensions
are transformed by the current model-view matrix.
</p>
<p>
The rectangle is intersected with the current clip region. To undo
the effect of this function, call <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-pop-clip" title="cogl_framebuffer_pop_clip ()"><code class="function">cogl_framebuffer_pop_clip()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_1</code></em> :</span></p></td>
<td>x coordinate for top left corner of the clip rectangle</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_1</code></em> :</span></p></td>
<td>y coordinate for top left corner of the clip rectangle</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x_2</code></em> :</span></p></td>
<td>x coordinate for bottom right corner of the clip rectangle</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y_2</code></em> :</span></p></td>
<td>y coordinate for bottom right corner of the clip rectangle</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-push-primitive-clip"></a><h3>cogl_framebuffer_push_primitive_clip ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_push_primitive_clip
                                                        (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Primitives.html#CoglPrimitive" title="CoglPrimitive"><span class="type">CoglPrimitive</span></a> *primitive</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_x1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_y1</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_x2</code></em>,
                                                         <em class="parameter"><code><span class="type">float</span> bounds_y2</code></em>);</pre>
<p>
Sets a new clipping area using a 2D shaped described with a
<a class="link" href="cogl-2.0-experimental-Primitives.html#CoglPrimitive" title="CoglPrimitive"><span class="type">CoglPrimitive</span></a>. The shape must not contain self overlapping
geometry and must lie on a single 2D plane. A bounding box of the
2D shape in local coordinates (the same coordinates used to
describe the shape) must be given. It is acceptable for the bounds
to be larger than the true bounds but behaviour is undefined if the
bounds are smaller than the true bounds.
</p>
<p>
The primitive is transformed by the current model-view matrix and
the silhouette is intersected with the previous clipping area.  To
restore the previous clipping area, call
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-framebuffer-pop-clip" title="cogl_framebuffer_pop_clip ()"><code class="function">cogl_framebuffer_pop_clip()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>primitive</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-Primitives.html#CoglPrimitive" title="CoglPrimitive"><span class="type">CoglPrimitive</span></a> describing a flat 2D shape</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bounds_x1</code></em> :</span></p></td>
<td>x coordinate for the top-left corner of the primitives
bounds</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bounds_y1</code></em> :</span></p></td>
<td>y coordinate for the top-left corner of the primitives
bounds</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bounds_x2</code></em> :</span></p></td>
<td>x coordinate for the top-left corner of the primitives
bounds</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bounds_y2</code></em> :</span></p></td>
<td>x coordinate for the bottom-right corner of the
primitives bounds.</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bounds_x1</code></em> :</span></p></td>
<td>y coordinate for the bottom-right corner of the
primitives bounds.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-framebuffer-pop-clip"></a><h3>cogl_framebuffer_pop_clip ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_framebuffer_pop_clip           (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *framebuffer</code></em>);</pre>
<p>
Reverts the clipping region to the state before the last call to
<code class="function">cogl_framebuffer_push_clip()</code>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>framebuffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> pointer</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-get-draw-framebuffer"></a><h3>cogl_get_draw_framebuffer ()</h3>
<pre class="programlisting"><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="returnvalue">CoglFramebuffer</span></a> *   cogl_get_draw_framebuffer           (<em class="parameter"><code><span class="type">void</span></code></em>);</pre>
<p>
Gets the current <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> as set using
<a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-push-framebuffer" title="cogl_push_framebuffer ()"><code class="function">cogl_push_framebuffer()</code></a>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>The current <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a>
</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.8</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-set-framebuffer"></a><h3>cogl_set_framebuffer ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_set_framebuffer                (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *buffer</code></em>);</pre>
<p>
This redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with <a class="link" href="cogl-2.0-experimental-Offscreen-Framebuffers.html#cogl-offscreen-new-to-texture" title="cogl_offscreen_new_to_texture ()"><code class="function">cogl_offscreen_new_to_texture()</code></a>
or in the future it may be an onscreen framebuffers too.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>buffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> object, either onscreen or offscreen.</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.2</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-push-framebuffer"></a><h3>cogl_push_framebuffer ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_push_framebuffer               (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> *buffer</code></em>);</pre>
<p>
Redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with <a class="link" href="cogl-2.0-experimental-Offscreen-Framebuffers.html#cogl-offscreen-new-to-texture" title="cogl_offscreen_new_to_texture ()"><code class="function">cogl_offscreen_new_to_texture()</code></a>
or in the future it may be an onscreen framebuffer too.
</p>
<p>
You should understand that a framebuffer owns the following state:
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">The projection matrix</li>
<li class="listitem">The modelview matrix stack</li>
<li class="listitem">The viewport</li>
<li class="listitem">The clip stack</li>
</ul></div>
<p>
So these items will automatically be saved and restored when you
push and pop between different framebuffers.
</p>
<p>
Also remember a newly allocated framebuffer will have an identity matrix for
the projection and modelview matrices which gives you a coordinate space
like OpenGL with (-1, -1) corresponding to the top left of the viewport,
(1, 1) corresponding to the bottom right and +z coming out towards the
viewer.
</p>
<p>
If you want to set up a coordinate space like Clutter does with (0, 0)
corresponding to the top left and (framebuffer_width, framebuffer_height)
corresponding to the bottom right you can do so like this:
</p>
<p>
</p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span>
<span class="function">setup_viewport</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> width</span><span class="symbol">,</span>
<span class="normal">                </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> height</span><span class="symbol">,</span>
<span class="normal">                </span><span class="type">float</span><span class="normal"> fovy</span><span class="symbol">,</span>
<span class="normal">                </span><span class="type">float</span><span class="normal"> aspect</span><span class="symbol">,</span>
<span class="normal">                </span><span class="type">float</span><span class="normal"> z_near</span><span class="symbol">,</span>
<span class="normal">                </span><span class="type">float</span><span class="normal"> z_far</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">  </span><span class="type">float</span><span class="normal"> z_camera</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">CoglMatrix</span><span class="normal"> projection_matrix</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">CoglMatrix</span><span class="normal"> mv_matrix</span><span class="symbol">;</span>

<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-The-Top-Level-Context.html#cogl-set-viewport">cogl_set_viewport</a></span><span class="normal"> </span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> width</span><span class="symbol">,</span><span class="normal"> height</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-The-Top-Level-Context.html#cogl-perspective">cogl_perspective</a></span><span class="normal"> </span><span class="symbol">(</span><span class="normal">fovy</span><span class="symbol">,</span><span class="normal"> aspect</span><span class="symbol">,</span><span class="normal"> z_near</span><span class="symbol">,</span><span class="normal"> z_far</span><span class="symbol">);</span>

<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-The-Top-Level-Context.html#cogl-get-projection-matrix">cogl_get_projection_matrix</a></span><span class="normal"> </span><span class="symbol">(&amp;</span><span class="normal">projection_matrix</span><span class="symbol">);</span>
<span class="normal">  z_camera </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0.5</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> projection_matrix</span><span class="symbol">.</span><span class="normal">xx</span><span class="symbol">;</span>

<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-Matrices.html#cogl-matrix-init-identity">cogl_matrix_init_identity</a></span><span class="normal"> </span><span class="symbol">(&amp;</span><span class="normal">mv_matrix</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-Matrices.html#cogl-matrix-translate">cogl_matrix_translate</a></span><span class="normal"> </span><span class="symbol">(&amp;</span><span class="normal">mv_matrix</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">0</span><span class="symbol">.</span><span class="normal">5f</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">0</span><span class="symbol">.</span><span class="normal">5f</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="normal">z_camera</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-Matrices.html#cogl-matrix-scale">cogl_matrix_scale</a></span><span class="normal"> </span><span class="symbol">(&amp;</span><span class="normal">mv_matrix</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">.</span><span class="normal">0f </span><span class="symbol">/</span><span class="normal"> width</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">.</span><span class="normal">0f </span><span class="symbol">/</span><span class="normal"> height</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">.</span><span class="normal">0f </span><span class="symbol">/</span><span class="normal"> width</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-Matrices.html#cogl-matrix-translate">cogl_matrix_translate</a></span><span class="normal"> </span><span class="symbol">(&amp;</span><span class="normal">mv_matrix</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">.</span><span class="normal">0f</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1.0</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> height</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">.</span><span class="normal">0f</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-The-Top-Level-Context.html#cogl-set-modelview-matrix">cogl_set_modelview_matrix</a></span><span class="normal"> </span><span class="symbol">(&amp;</span><span class="normal">mv_matrix</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span>
<span class="function">my_init_framebuffer</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">ClutterStage</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">stage</span><span class="symbol">,</span>
<span class="normal">                     </span><span class="usertype">CoglFramebuffer</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">framebuffer</span><span class="symbol">,</span>
<span class="normal">                     </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> framebuffer_width</span><span class="symbol">,</span>
<span class="normal">                     </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> framebuffer_height</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">ClutterPerspective</span><span class="normal"> perspective</span><span class="symbol">;</span>

<span class="normal">  </span><span class="function">clutter_stage_get_perspective</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">stage</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">perspective</span><span class="symbol">);</span>

<span class="normal">  </span><span class="function"><a href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-push-framebuffer">cogl_push_framebuffer</a></span><span class="normal"> </span><span class="symbol">(</span><span class="normal">framebuffer</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">setup_viewport</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">framebuffer_width</span><span class="symbol">,</span>
<span class="normal">                  framebuffer_height</span><span class="symbol">,</span>
<span class="normal">                  perspective</span><span class="symbol">.</span><span class="normal">fovy</span><span class="symbol">,</span>
<span class="normal">                  perspective</span><span class="symbol">.</span><span class="normal">aspect</span><span class="symbol">,</span>
<span class="normal">                  perspective</span><span class="symbol">.</span><span class="normal">z_near</span><span class="symbol">,</span>
<span class="normal">                  perspective</span><span class="symbol">.</span><span class="normal">z_far</span><span class="symbol">);</span>
<span class="cbracket">}</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
</p>
<p>
The previous framebuffer can be restored by calling <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#cogl-pop-framebuffer" title="cogl_pop_framebuffer ()"><code class="function">cogl_pop_framebuffer()</code></a>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>buffer</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-CoglFramebuffer---The-Framebuffer-Interface.html#CoglFramebuffer" title="CoglFramebuffer"><span class="type">CoglFramebuffer</span></a> object, either onscreen or offscreen.</td>
</tr></tbody>
</table></div>
<p class="since">Since 1.2</p>
</div>
<hr>
<div class="refsect2">
<a name="cogl-pop-framebuffer"></a><h3>cogl_pop_framebuffer ()</h3>
<pre class="programlisting"><span class="returnvalue">void</span>                cogl_pop_framebuffer                (<em class="parameter"><code><span class="type">void</span></code></em>);</pre>
<p>
Restores the framebuffer that was previously at the top of the stack.
All subsequent drawing will be redirected to this framebuffer.
</p>
<p class="since">Since 1.2</p>
</div>
</div>
</div>
<div class="footer">
<hr>
          Generated by GTK-Doc V1.18.1</div>
</body>
</html>