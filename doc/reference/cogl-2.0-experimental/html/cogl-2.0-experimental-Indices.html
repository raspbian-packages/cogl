<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Indices</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="index.html" title="Cogl 2.0 Reference Manual">
<link rel="up" href="cogl-buffer-layout-apis.html" title="Describing the layout of GPU Memory">
<link rel="prev" href="cogl-2.0-experimental-Vertex-Attributes.html" title="Vertex Attributes">
<link rel="next" href="cogl-primitive-apis.html" title="Geometry">
<meta name="generator" content="GTK-Doc V1.19.1 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
<tr valign="middle">
<td><a accesskey="p" href="cogl-2.0-experimental-Vertex-Attributes.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="cogl-buffer-layout-apis.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">Cogl 2.0 Reference Manual</th>
<td><a accesskey="n" href="cogl-primitive-apis.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr>
<tr><td colspan="5" class="shortcuts">
<a href="#cogl-2.0-experimental-Indices.synopsis" class="shortcut">Top</a>
                   | 
                  <a href="#cogl-2.0-experimental-Indices.description" class="shortcut">Description</a>
</td></tr>
</table>
<div class="refentry">
<a name="cogl-2.0-experimental-Indices"></a><div class="titlepage"></div>
<div class="refnamediv"><table width="100%"><tr>
<td valign="top">
<h2><span class="refentrytitle"><a name="cogl-2.0-experimental-Indices.top_of_page"></a>Indices</span></h2>
<p>Indices — Describe vertex indices stored in a <a class="link" href="cogl-2.0-experimental-CoglIndexBuffer---Buffers-of-vertex-indices.html#CoglIndexBuffer" title="CoglIndexBuffer"><span class="type">CoglIndexBuffer</span></a>.</p>
</td>
<td valign="top" align="right"></td>
</tr></table></div>
<div class="refsynopsisdiv">
<a name="cogl-2.0-experimental-Indices.synopsis"></a><h2>Synopsis</h2>
<pre class="synopsis">                    <a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndices" title="CoglIndices">CoglIndices</a>;
<a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglBool" title="CoglBool"><span class="returnvalue">CoglBool</span></a>            <a class="link" href="cogl-2.0-experimental-Indices.html#cogl-is-indices" title="cogl_is_indices ()">cogl_is_indices</a>                     (<em class="parameter"><code><span class="type">void</span> *object</code></em>);

enum                <a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndicesType" title="enum CoglIndicesType">CoglIndicesType</a>;
<a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndices" title="CoglIndices"><span class="returnvalue">CoglIndices</span></a> *       <a class="link" href="cogl-2.0-experimental-Indices.html#cogl-indices-new" title="cogl_indices_new ()">cogl_indices_new</a>                    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-The-Top-Level-Context.html#CoglContext" title="CoglContext"><span class="type">CoglContext</span></a> *context</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndicesType" title="enum CoglIndicesType"><span class="type">CoglIndicesType</span></a> type</code></em>,
                                                         <em class="parameter"><code>const <span class="type">void</span> *indices_data</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_indices</code></em>);

<a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndices" title="CoglIndices"><span class="returnvalue">CoglIndices</span></a> *       <a class="link" href="cogl-2.0-experimental-Indices.html#cogl-get-rectangle-indices" title="cogl_get_rectangle_indices ()">cogl_get_rectangle_indices</a>          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-The-Top-Level-Context.html#CoglContext" title="CoglContext"><span class="type">CoglContext</span></a> *context</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_rectangles</code></em>);
</pre>
</div>
<div class="refsect1">
<a name="cogl-2.0-experimental-Indices.description"></a><h2>Description</h2>
<p>
Indices allow you to avoid duplicating vertices in your vertex data
by virtualizing your data and instead providing a sequence of index
values that tell the GPU which data should be used for each vertex.
</p>
<p>
If the GPU is given a sequence of indices it doesn't simply walk
through each vertex of your data in order it will instead walk
through the indices which can provide random access to the
underlying data.
</p>
<p>
Since it's very common to have duplicate vertices when describing a
shape as a list of triangles it can often be a significant space
saving to describe geometry using indices. Reducing the size of
your models can make it cheaper to map them into the GPU by
reducing the demand on memory bandwidth and may help to make better
use of your GPUs internal vertex caching.
</p>
<p>
For example, to describe a quadrilateral as 2 triangles for the GPU
you could either provide data with 6 vertices or instead with
indices you can provide vertex data for just 4 vertices and an
index buffer that specfies the 6 vertices by indexing the shared
vertices multiple times.
</p>
<p>
</p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></td>
        <td class="listing_code"><pre class="programlisting"><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="syntax" content="cpp" />
<meta name="settings" content="use_xhtml,use_css,pre_wrap,no_foldcolumn,prevent_copy=" />
<meta name="colorscheme" content="none" />
<style type="text/css">

pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Constant { color: #0000c0; text-decoration: underline; }
.Comment { color: #c00000; font-weight: bold; }
.Type { color: #008000; text-decoration: underline; }

</style>

<script type='text/javascript'>
//<![CDATA[

//]]>
</script>
</head>
<body>
<pre id='vimCodeElement'>
CoglVertex2f quad_vertices[] = {
    {x0, y0}, <span class="comment">//0 = top left</span>
    {x1, y1}, <span class="comment">//1 = bottom left</span>
    {x2, y2}, <span class="comment">//2 = bottom right</span>
    {x3, y3}, <span class="comment">//3 = top right</span>
  };
  <span class="comment">//tell the gpu how to interpret the quad as 2 triangles...</span>
  <span class="type">unsigned</span> <span class="type">char</span> indices[] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>};</pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
</p>
<p>
Even in the above illustration we see a saving of 10bytes for one
quad compared to having data for 6 vertices and no indices but if
you need to draw 100s or 1000s of quads then its really quite
significant.
</p>
<p>
Something else to consider is that often indices can be defined
once and remain static while the vertex data may change for
animations perhaps. That means you may be able to ignore the
negligable cost of mapping your indices into the GPU if they don't
ever change.
</p>
<p>
The above illustration is actually a good example of static indices
because it's really common that developers have quad mesh data that
they need to display and we know exactly what that indices array
needs to look like depending on the number of quads that need to be
drawn. It doesn't matter how the quads might be animated and
changed the indices will remain the same. Cogl even has a utility
(<a class="link" href="cogl-2.0-experimental-Indices.html#cogl-get-rectangle-indices" title="cogl_get_rectangle_indices ()"><code class="function">cogl_get_rectangle_indices()</code></a>) to get access to re-useable indices
for drawing quads as above.
</p>
</div>
<div class="refsect1">
<a name="cogl-2.0-experimental-Indices.details"></a><h2>Details</h2>
<div class="refsect2">
<a name="CoglIndices"></a><h3>CoglIndices</h3>
<pre class="programlisting">typedef struct _CoglIndices CoglIndices;</pre>
</div>
<hr>
<div class="refsect2">
<a name="cogl-is-indices"></a><h3>cogl_is_indices ()</h3>
<pre class="programlisting"><a class="link" href="cogl-2.0-experimental-Common-Types.html#CoglBool" title="CoglBool"><span class="returnvalue">CoglBool</span></a>            cogl_is_indices                     (<em class="parameter"><code><span class="type">void</span> *object</code></em>);</pre>
<p>
Gets whether the given object references a <a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndices" title="CoglIndices"><span class="type">CoglIndices</span></a>.
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>object</code></em> :</span></p></td>
<td>A <a class="link" href="cogl-2.0-experimental-The-Object-Interface.html#CoglObject" title="CoglObject"><span class="type">CoglObject</span></a> pointer</td>
</tr>
<tr>
<td><p><span class="term"><span class="emphasis"><em>Returns</em></span> :</span></p></td>
<td>
<code class="literal">TRUE</code> if the object references a <a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndices" title="CoglIndices"><span class="type">CoglIndices</span></a>
and <code class="literal">FALSE</code> otherwise.</td>
</tr>
</tbody>
</table></div>
<p class="since">Since 1.10</p>
<p class="stability">Stability Level: Unstable</p>
</div>
<hr>
<div class="refsect2">
<a name="CoglIndicesType"></a><h3>enum CoglIndicesType</h3>
<pre class="programlisting">typedef enum {
  COGL_INDICES_TYPE_UNSIGNED_BYTE,
  COGL_INDICES_TYPE_UNSIGNED_SHORT,
  COGL_INDICES_TYPE_UNSIGNED_INT
} CoglIndicesType;
</pre>
<p>
You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.
</p>
<p>
Note that <a class="link" href="cogl-2.0-experimental-Indices.html#COGL-INDICES-TYPE-UNSIGNED-INT:CAPS"><code class="literal">COGL_INDICES_TYPE_UNSIGNED_INT</code></a> is only supported if the
<a class="link" href="cogl-2.0-experimental-The-Top-Level-Context.html#COGL-FEATURE-ID-UNSIGNED-INT-INDICES:CAPS"><code class="literal">COGL_FEATURE_ID_UNSIGNED_INT_INDICES</code></a> feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized.
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><a name="COGL-INDICES-TYPE-UNSIGNED-BYTE:CAPS"></a><span class="term"><code class="literal">COGL_INDICES_TYPE_UNSIGNED_BYTE</code></span></p></td>
<td>Your indices are unsigned bytes
</td>
</tr>
<tr>
<td><p><a name="COGL-INDICES-TYPE-UNSIGNED-SHORT:CAPS"></a><span class="term"><code class="literal">COGL_INDICES_TYPE_UNSIGNED_SHORT</code></span></p></td>
<td>Your indices are unsigned shorts
</td>
</tr>
<tr>
<td><p><a name="COGL-INDICES-TYPE-UNSIGNED-INT:CAPS"></a><span class="term"><code class="literal">COGL_INDICES_TYPE_UNSIGNED_INT</code></span></p></td>
<td>Your indices are unsigned ints
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2">
<a name="cogl-indices-new"></a><h3>cogl_indices_new ()</h3>
<pre class="programlisting"><a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndices" title="CoglIndices"><span class="returnvalue">CoglIndices</span></a> *       cogl_indices_new                    (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-The-Top-Level-Context.html#CoglContext" title="CoglContext"><span class="type">CoglContext</span></a> *context</code></em>,
                                                         <em class="parameter"><code><a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndicesType" title="enum CoglIndicesType"><span class="type">CoglIndicesType</span></a> type</code></em>,
                                                         <em class="parameter"><code>const <span class="type">void</span> *indices_data</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_indices</code></em>);</pre>
</div>
<hr>
<div class="refsect2">
<a name="cogl-get-rectangle-indices"></a><h3>cogl_get_rectangle_indices ()</h3>
<pre class="programlisting"><a class="link" href="cogl-2.0-experimental-Indices.html#CoglIndices" title="CoglIndices"><span class="returnvalue">CoglIndices</span></a> *       cogl_get_rectangle_indices          (<em class="parameter"><code><a class="link" href="cogl-2.0-experimental-The-Top-Level-Context.html#CoglContext" title="CoglContext"><span class="type">CoglContext</span></a> *context</code></em>,
                                                         <em class="parameter"><code><span class="type">int</span> n_rectangles</code></em>);</pre>
</div>
</div>
</div>
<div class="footer">
<hr>
          Generated by GTK-Doc V1.19.1</div>
</body>
</html>